<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NFT Minting - Arcadia Node</title>
    <link rel="stylesheet" href="/css/common.css">
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
</head>
<body class="bg-gray-100">
    <div class="header bg-white shadow-md">
        <div class="container mx-auto px-4 py-4">
            <div class="flex justify-between items-center">
                <a href="/" id="backToHome" class="text-blue-600 hover:text-blue-800">← Back to Home</a>
                <div class="language-selector">
                    <select id="languageSelect" class="px-2 py-1 border rounded">
                        <option value="en">English</option>
                        <option value="zh">中文</option>
                    </select>
                </div>
            </div>
            <h1 id="pageTitle" class="text-2xl font-bold text-center mt-4">NFT Minting</h1>
        </div>
    </div>

    <div class="container mx-auto px-4 py-8">
        <!-- Chain Selection -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h2 class="text-xl font-semibold mb-4" id="selectChainTitle">Select Chain</h2>
            <div class="flex space-x-4">
                <button id="ethereumChain" class="px-6 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors flex items-center space-x-2">
                    <img src="/images/ethereum.svg" alt="Ethereum" class="w-6 h-6">
                    <span>Ethereum</span>
                </button>
                <button id="aptosChain" class="px-6 py-3 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors flex items-center space-x-2">
                    <img src="/images/aptos.svg" alt="Aptos" class="w-6 h-6">
                    <span>Aptos</span>
                </button>
            </div>
        </div>

        <!-- Loading State -->
        <div id="loadingState" class="hidden">
            <div class="flex justify-center items-center py-12">
                <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500"></div>
            </div>
        </div>

        <!-- Error State -->
        <div id="errorState" class="hidden">
            <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
                <strong class="font-bold">Error!</strong>
                <span id="errorMessage" class="block sm:inline"></span>
            </div>
        </div>

        <!-- NFT Grid -->
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6" id="nftList">
            <!-- NFT cards will be dynamically added here -->
        </div>

        <!-- Mint Modal -->
        <div id="mintModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div class="bg-white rounded-lg p-6 max-w-md w-full mx-4">
                <h3 class="text-xl font-semibold mb-4" id="mintModalTitle">Mint NFT</h3>
                
                <div class="mb-6">
                    <div class="flex justify-between mb-2">
                        <span class="text-gray-600">NFT ID:</span>
                        <span id="mintNftId" class="font-medium"></span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-600">Price:</span>
                        <span id="mintPrice" class="font-medium"></span>
                    </div>
                </div>

                <div class="mb-6">
                    <label class="block text-sm font-medium text-gray-700 mb-2" id="paymentMethodLabel">Payment Method</label>
                    <select id="paymentMethod" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500">
                        <option value="native">Native Token</option>
                        <option value="token">ERC20/Aptos Token</option>
                    </select>
                </div>

                <!-- Minting Progress -->
                <div id="mintProgress" class="hidden mb-4">
                    <div class="w-full bg-gray-200 rounded-full h-2">
                        <div class="bg-blue-500 h-2 rounded-full transition-all duration-500" style="width: 0%"></div>
                    </div>
                    <p id="mintStatus" class="text-sm text-gray-600 mt-2 text-center"></p>
                </div>

                <div class="flex justify-end space-x-4">
                    <button id="cancelMint" class="px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors">Cancel</button>
                    <button id="confirmMint" class="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors">Confirm</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 先加载库文件 -->
    <script src="/js/ethers.umd.min.js"></script>
    <script src="/js/aptos.js"></script>
    <script src="/js/config.js"></script>
    <script src="/js/contracts/heroNftABI.js"></script>

    <!-- 然后加载应用代码 -->
    <script type="module">
        // Types
        const ChainType = {
            ETHEREUM: 'ethereum',
            APTOS: 'aptos'
        };

        const PaymentType = {
            NATIVE: 'native',
            TOKEN: 'token'
        };

        // State
        let currentChain = ChainType.ETHEREUM;
        let provider;
        let aptosClient;
        let nftContract;
        let selectedNft = null;
        let isLoading = false;

        // Initialize
        async function init() {
            try {
                showLoading(true);
                
                // 添加环境检查
                config.checkEnvironment();
                
                // 初始化providers
                if (window.ethereum) {
                    provider = new ethers.BrowserProvider(window.ethereum);
                    const network = await provider.getNetwork();
                    config.log('Connected to network:', network);
                    
                    // 检查合约加载
                    config.checkContractLoading();
                    
                    nftContract = new ethers.Contract(
                        config.ethereum.contracts.heroNft,
                        heroNftABI,
                        provider
                    );
                    config.log('NFT contract initialized:', nftContract.address);
                }

                aptosClient = new AptosClient(config.aptos.nodeUrl);
                config.log('Aptos client initialized');

                // Load initial NFTs
                await loadNFTs();
                config.log('Initial NFTs loaded');

                // Bind events
                setupEventListeners();
                config.log('Event listeners set up');
                
                // Initialize language
                updateLanguage(localStorage.getItem('language') || 'en');
                config.log('Language initialized');
            } catch (error) {
                config.log('Initialization error:', error);
                showError(error.message);
            } finally {
                showLoading(false);
            }
        }

        function setupEventListeners() {
            document.getElementById('ethereumChain').onclick = () => switchChain(ChainType.ETHEREUM);
            document.getElementById('aptosChain').onclick = () => switchChain(ChainType.APTOS);
            document.getElementById('cancelMint').onclick = closeMintModal;
            document.getElementById('confirmMint').onclick = mint;
            document.getElementById('languageSelect').onchange = (e) => updateLanguage(e.target.value);
        }

        async function switchChain(chain) {
            try {
                showLoading(true);
                currentChain = chain;
                
                // Update UI
                document.getElementById('ethereumChain').classList.toggle('bg-blue-500', chain === ChainType.ETHEREUM);
                document.getElementById('aptosChain').classList.toggle('bg-blue-500', chain === ChainType.APTOS);
                
                // Switch network if needed
                if (chain === ChainType.ETHEREUM && window.ethereum) {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: config.ethereum.chainId }],
                    });
                }
                
                await loadNFTs();
            } catch (error) {
                showError(error.message);
            } finally {
                showLoading(false);
            }
        }

        async function loadNFTs() {
            const nftList = document.getElementById('nftList');
            nftList.innerHTML = '';

            try {
                const nfts = currentChain === ChainType.ETHEREUM 
                    ? await loadEthereumNFTs()
                    : await loadAptosNFTs();

                nfts.forEach(nft => {
                    const card = createNFTCard(nft);
                    nftList.appendChild(card);
                });
            } catch (error) {
                showError('Failed to load NFTs: ' + error.message);
            }
        }

        function createNFTCard(nft) {
            const div = document.createElement('div');
            div.className = 'bg-white rounded-lg shadow-lg overflow-hidden transform transition-transform hover:scale-105';
            div.innerHTML = `
                <div class="relative pb-2/3">
                    <img src="${nft.image}" alt="${nft.name}" class="absolute h-full w-full object-cover">
                </div>
                <div class="p-4">
                    <h3 class="text-lg font-semibold mb-2">${nft.name}</h3>
                    <p class="text-gray-600 mb-4">Price: ${nft.price} ${currentChain === ChainType.ETHEREUM ? 'ETH' : 'APT'}</p>
                    <button class="w-full px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors"
                            onclick="window.openMintModal(${JSON.stringify(nft)})">
                        Mint
                    </button>
                </div>
            `;
            return div;
        }

        function showLoading(show) {
            isLoading = show;
            document.getElementById('loadingState').classList.toggle('hidden', !show);
        }

        function showError(message) {
            const errorState = document.getElementById('errorState');
            const errorMessage = document.getElementById('errorMessage');
            errorMessage.textContent = message;
            errorState.classList.remove('hidden');
            setTimeout(() => {
                errorState.classList.add('hidden');
            }, 5000);
        }

        function updateMintProgress(progress, status) {
            const progressBar = document.querySelector('#mintProgress .bg-blue-500');
            const statusText = document.getElementById('mintStatus');
            document.getElementById('mintProgress').classList.remove('hidden');
            progressBar.style.width = `${progress}%`;
            statusText.textContent = status;
        }

        // Export necessary functions to window
        window.openMintModal = function(nft) {
            selectedNft = nft;
            document.getElementById('mintNftId').textContent = nft.tokenId;
            document.getElementById('mintPrice').textContent = `${nft.price} ${currentChain === ChainType.ETHEREUM ? 'ETH' : 'APT'}`;
            document.getElementById('mintModal').classList.remove('hidden');
        };

        window.closeMintModal = function() {
            selectedNft = null;
            document.getElementById('mintModal').classList.add('hidden');
            document.getElementById('mintProgress').classList.add('hidden');
        };

        async function mint() {
            if (!selectedNft) return;

            try {
                const paymentMethod = document.getElementById('paymentMethod').value;
                updateMintProgress(0, 'Initializing transaction...');
                
                if (currentChain === ChainType.ETHEREUM) {
                    await mintEthereumNFT(selectedNft, paymentMethod);
                } else {
                    await mintAptosNFT(selectedNft, paymentMethod);
                }

                updateMintProgress(100, 'Minting successful!');
                setTimeout(() => {
                    closeMintModal();
                    loadNFTs(); // Refresh NFT list
                }, 2000);
            } catch (error) {
                console.error('Minting failed:', error);
                updateMintProgress(0, `Minting failed: ${error.message}`);
            }
        }

        async function mintEthereumNFT(nft, paymentMethod) {
            if (!window.ethereum) {
                throw new Error('MetaMask is not installed');
            }

            const signer = await provider.getSigner();
            const contract = nftContract.connect(signer);

            updateMintProgress(20, 'Waiting for wallet approval...');

            try {
                let tx;
                if (paymentMethod === PaymentType.NATIVE) {
                    tx = await contract.mint(
                        await signer.getAddress(),
                        nft.tokenId,
                        { value: ethers.parseEther(nft.price) }
                    );
                } else {
                    // First approve token spending if needed
                    const tokenContract = new ethers.Contract(
                        nft.priceToken,
                        ['function approve(address spender, uint256 amount) public returns (bool)'],
                        signer
                    );

                    updateMintProgress(40, 'Approving token spending...');
                    const approveTx = await tokenContract.approve(
                        contract.address,
                        ethers.parseEther(nft.price)
                    );
                    await approveTx.wait();

                    updateMintProgress(60, 'Minting NFT...');
                    tx = await contract.mintWithToken(
                        await signer.getAddress(),
                        nft.tokenId
                    );
                }

                updateMintProgress(80, 'Waiting for confirmation...');
                await tx.wait();
            } catch (error) {
                if (error.code === 4001) {
                    throw new Error('Transaction rejected by user');
                }
                throw error;
            }
        }

        async function mintAptosNFT(nft, paymentMethod) {
            if (!window.aptos) {
                throw new Error('Petra Wallet is not installed');
            }

            updateMintProgress(20, 'Preparing transaction...');

            const payload = {
                type: 'entry_function_payload',
                function: `${config.aptos.contracts.heroNft}::hero_nft::mint`,
                type_arguments: [],
                arguments: [
                    nft.tokenId,
                    paymentMethod === PaymentType.NATIVE ? [] : [nft.priceToken]
                ]
            };

            try {
                updateMintProgress(40, 'Waiting for wallet approval...');
                const response = await window.aptos.signAndSubmitTransaction(payload);

                updateMintProgress(60, 'Waiting for confirmation...');
                await aptosClient.waitForTransaction(response.hash);
            } catch (error) {
                if (error.code === 'user_rejected') {
                    throw new Error('Transaction rejected by user');
                }
                throw error;
            }
        }

        async function loadEthereumNFTs() {
            try {
                const totalSupply = await nftContract.totalSupply();
                const nfts = [];

                for (let i = 0; i < totalSupply; i++) {
                    const tokenId = await nftContract.tokenByIndex(i);
                    const [price, priceToken, uri] = await Promise.all([
                        nftContract.getNativePrice(tokenId),
                        nftContract.getTokenPrice(tokenId),
                        nftContract.tokenURI(tokenId)
                    ]);

                    // Fetch metadata from IPFS
                    const response = await fetch(uri);
                    const metadata = await response.json();

                    nfts.push({
                        tokenId: tokenId.toString(),
                        name: metadata.name,
                        image: metadata.image,
                        price: ethers.formatEther(price),
                        priceToken: priceToken
                    });
                }

                return nfts;
            } catch (error) {
                console.error('Failed to load Ethereum NFTs:', error);
                throw new Error('Failed to load NFTs');
            }
        }

        async function loadAptosNFTs() {
            try {
                const resources = await aptosClient.getAccountResources(
                    config.aptos.contracts.heroNft
                );

                const nftResource = resources.find(r => 
                    r.type === `${config.aptos.contracts.heroNft}::hero_nft::Collection`
                );

                if (!nftResource) {
                    throw new Error('NFT collection not found');
                }

                const nfts = [];
                for (const [tokenId, data] of Object.entries(nftResource.data.tokens)) {
                    // Fetch metadata from IPFS
                    const response = await fetch(data.uri);
                    const metadata = await response.json();

                    nfts.push({
                        tokenId,
                        name: metadata.name,
                        image: metadata.image,
                        price: data.native_price,
                        priceToken: data.token_price.token
                    });
                }

                return nfts;
            } catch (error) {
                console.error('Failed to load Aptos NFTs:', error);
                throw new Error('Failed to load NFTs');
            }
        }

        function updateLanguage(lang) {
            const translations = {
                en: {
                    title: 'NFT Minting',
                    backToHome: '← Back to Home',
                    selectChain: 'Select Chain',
                    mintNFT: 'Mint NFT',
                    price: 'Price',
                    paymentMethod: 'Payment Method',
                    native: 'Native Token',
                    token: 'ERC20/Aptos Token',
                    cancel: 'Cancel',
                    confirm: 'Confirm',
                    mint: 'Mint'
                },
                zh: {
                    title: 'NFT 铸造',
                    backToHome: '← 返回首页',
                    selectChain: '选择链',
                    mintNFT: '铸造 NFT',
                    price: '价格',
                    paymentMethod: '支付方式',
                    native: '原生代币',
                    token: 'ERC20/Aptos 代币',
                    cancel: '取消',
                    confirm: '确认',
                    mint: '铸造'
                }
            };

            const t = translations[lang] || translations.en;
            
            // Update all text content
            document.getElementById('pageTitle').textContent = t.title;
            document.getElementById('backToHome').textContent = t.backToHome;
            document.getElementById('selectChainTitle').textContent = t.selectChain;
            document.getElementById('mintModalTitle').textContent = t.mintNFT;
            document.getElementById('paymentMethodLabel').textContent = t.paymentMethod;
            document.getElementById('cancelMint').textContent = t.cancel;
            document.getElementById('confirmMint').textContent = t.confirm;

            // Update payment method options
            const paymentMethod = document.getElementById('paymentMethod');
            paymentMethod.options[0].text = t.native;
            paymentMethod.options[1].text = t.token;

            // Update all mint buttons
            document.querySelectorAll('#nftList button').forEach(button => {
                button.textContent = t.mint;
            });
        }

        // Initialize on page load
        window.addEventListener('load', init);
    </script>
</body>
</html> 